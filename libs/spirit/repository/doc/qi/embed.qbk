[/==============================================================================
    Copyright (C) 2001-2011 Joel de Guzman
    Copyright (C) 2001-2011 Hartmut Kaiser
    Copyright (C) 2011 Jamboree 

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:embed Qi Embed Parser Directive ]

[heading Description]

The `embed[]` parser-directive provides a mechanism for parsing against the
embedded range instead of normal input. 

A __range__ is a general concept, such as STL container, `std::string`,
and __boost_iterator_range__ are all ranges. 
For __qi__, it's natively __boost_iterator_range__,
as what you get from `qi::raw[]`.

__qi__ requires __fwd_range__.
There's no restriction imposed on the range type, even whiches range-iterator
not compatible with input iterator can be used, while it actually depends on the
enclosed parser.

[heading Header]

    // forwards to <boost/spirit/repository/home/qi/directive/embed.hpp>
    #include <boost/spirit/repository/include/qi_embed.hpp>

Also, see __include_structure__.

[heading Namespace]

[table
    [[Name]]
    [[`boost::spirit::repository::qi::embed`]]
]

[heading Model of]

[:__unary_parser_concept__]

[variablelist Notation
    [[`rng`]        [A __fwd_range__, or a __qi_lazy_argument__ that evaluates to
                     __fwd_range__.]]
    [[`a`]          [A __parser_concept__.]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is
not defined in __unary_parser_concept__.

[table
    [[Expression]               [Semantics]]
    [[`embed(rng)[a]`]          [Parse `a` against `rng`, regardless of input.]]
]

[heading Attributes]

See __qi_comp_attr_notation__.

[table
    [[Expression]       [Attribute]]
    [[`embed(rng)[a]`]
[``a: A --> embed(rng)[a]: A
a: Unused --> embed(rng)[a]: Unused``]]
]

[heading Complexity]

[:The complexity is defined by the complexity of the subject parser, `a`]

[heading Example]

[import ../../example/qi/embed.cpp]

The following example shows a simple use case of the `embed[]` directive that
exploits Nabialek-Trick and demonstrates the basic error-handling ability.
(for the full example code, see [@../../example/qi/embed.cpp embed.cpp])

Some namespace aliases & using declaration:

[reference_qi_embed_namespace]

And some typedefs:

[reference_qi_embed_typedef]

Here we declare the rules and symbol table:

[reference_qi_embed_rule_decl]

Let's define our rules now:

[reference_qi_embed_rule_def_p1]

In `demo`, we try to match the keyword pattern `kwd_patt`, store the matched range
in the local variable `qi::_a`, and feed `full_kwd` with it through the `embed[]` directive.
After `full_kwd` matched, a corresponding rule is stored into the local variable
 `qi::_b` (by pointer), which we expect to match after seeing the keyword.

`full_kwd` expects a full-match of `kwd`.

`kwd_patt` matches string like C++ identifier, exposing the matched range.


Here's the rest of our rules:

[reference_qi_embed_rule_def_p2]

For error-handling:

[reference_qi_embed_rule_error_handling]

Since we use expectation-points in both the main rule `demo` and the embedded `full_kwd`,
we'd better define the error-handlers for them respectively.

[important *Embedded-Range & Error-Handling*

TODO]

[heading Samples]

[:In \[1\]:]

[pre
int a
]

[:Out \[1\]:]

[pre
\[demo\] Error! Expecting <int> here: "a"
-------------------------------- 
Parsing failed, rest: int a
-------------------------------- 
]

[:In \[2\]:]

[pre
double9.5
]

[:Out \[2\]:]

[pre
\[full_kwd\] Error! Expecting <eoi> here: "9"
-------------------------------- 
Parsing failed, rest: double9.5
-------------------------------- 
]

[endsect]
